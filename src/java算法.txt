一、数据结构
	1、线性结构：顺序存储结构(列表)和链式存储结构(链表)，数据元素之间具有一对一的线性关系
		①列表：存储的元素具有具有连续性
		②链表：不一定具有连续性(有可能在中间插入一个节点)
		③常见类型：数组、链表、栈和队列
		
	2、非线性结构包括：数据元素之间不一定是一对一的关系，也有可能是一对多的关系
		①常见类型：二维数组、多维数组、广义表、树结构、图结构
		
	3、稀疏数组：
		①结构：第一行记录着该对应矩阵的的结构(行、列、值——非零的个数)的情况
		②作用：第二行起就是就是记录矩阵的非零值的坐标(在矩阵中的行、列的位置)和值
	
	4、二维数组转稀疏数组的思路
		①遍历二维数组，得到有效数据(非零值)的个数sum
		②根据sum 和二维数组的根索引就可以创建稀疏数组sparseArr[sum+1][3]
		③将二维数组的有效数据的坐标(行、列)和值存入到稀疏数组中
	
	5、稀疏数组转二维数组的思路
		①先读取稀疏数组的第一行，根据第一行的数据(前面两列代表的是二维数组的行、列大小)，创建原始的二维数组
		②再从第二行开始读取稀疏数组的数据并根据指明的行、列、值写入到二维数组对应的位置即可
		
	6、队列：是一个有序列表，可以用数组或是链表来实现
		①规则：遵循先入先出的原则。即，先存入对列的数据，要先被取出，后存入队列的数据要被后取出。
		②结构：因为独立的输出输入分别是从前后端来处理，因此需要两个变量front(队首)、rear(队尾)，
			   分别记录队列前后端的下标，front会随着数据输出而变化，而rear则是随着数据的输入而变化。
		③front：当数据出队的时候自增1，数据入队不变化
		④rear：当数据入队的时候自增1，数据出队不变化
	
	7、使用数组模拟环形队列的思路分析
		a、front(初始值0)变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。
		b、rear(初始值0)变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置。因为希望空出一个空间作为约定。
		c、当队列满时，条件是：(rear + 1) % maxSize == front【满】
		d、当队列为空时的条件是：rear == front【空】
		e、当我们这样分析，队列中有效的数据的个数：(rear + maxSeize - front) % maxSize
		f、在上面几个条件下就可以在原来的队列进行改造得到一个环形队列。
	
	8、单向链表链表(Linked List)
		a、链表是以节点的方式来存储
		b、每个节点包含data域，next域：指向下一个节点
		c、链表的各个节点不一定是连续的存储
		d、链表分带头节点的链表和没有头结点的链表，根据实际需求来确定
		e、业务：把水浒传里的人物采用链表的方式展现出来
		f、节点结构
		    class Hero{ // 数据对象
		        int no;
                String name;
                String nickName;
		    }
			class Node{ // 节点
				Here data;
				HeroNode next;
			}
		g、需求：
			添加（创建）
				1、先创建一个head 头结点，作用就是表示单链表的头
				2、后面我们每添加一个节点，就直接赋值给链表最后节点的next域
			遍历：
				1、通过一个辅助遍历，帮助遍历整个链表
		h、缺点：
		    1、查找或遍历链表的方向只有一个
		    2、单向链表不能自我删除，只能依靠辅助节点

	9、双向链表
	    a、结构：相比于单向链表指向下一个节点next域，双向链表的节点多了个指向前一个节点的pre域
        b、分析：
            1、遍历方向和单向链表一样，只是可以向前查找也可以向后查找
            2、添加(默认添加到双向链表的最后)
				①先找到双向节点的最后一个节点
				②temp.next = newNode
				③newNode.pre = temp
			3、修改思路和原来的单向链表一样
			4、删除
			    ①因为是双向链表，因此我们可以实现直接自我删除某个节点
				②直接找到要删除的这个节点，比如temp
				③temp.pre.next = temp.next
				④temp.next.pre = temp.next(注意：若删除的是最后一个节点会报空指针异常)

	10、单向环形链表
	    a、约瑟夫问题：设编号为1,2,3....n个人围坐成一圈，约定编号为k(1<=k<=n)的人开始报数，数到m的那个人出列，
	       它的下一位又从1开始数，数到m的那个人又出列，依次类推，直到所有人都出列位置，由此产生的一个出队编号的序列。
	        如：
	            n = 10  总数10人
	            k = 1 从1号开始数数
	            m = 3   每次数到3的人出队
	    b、单向链表实现：用一个不带头结点的循环链表来处理josephu 问题
	        ①先构成一个有n个节点的单循环链表
	        ②然后由k节点开始计数，记到m时，对应节点从链表中删除
	        ③然后再从被删除节点的下一个节点又从1开始计数到m又删除
	        ④依次循环直到节点从链表中全部删除算法结束
	    c、构建单向的环形链表思路
	        ①先创建第一个节点，让first指向该节点，并形成环形
	        ②后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表中即可
	    d、遍历环形链表
	        ①先让一个辅助指针(变量)，指向first节点
	        ②然后通过一个while循环遍历该环形链表即可 curBoy.next == first

    11、栈(stack)
        a、栈是一个先进后出(FILO-first In Last Out)的有序列表
        b、栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。
           允许插入和删除的一端，为变化的一端，称为栈顶(top),另一端为固定的一端，称为栈底(bottom)。
        c、根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，
            最后放入的元素最先删除，最先放入的元素最后删除。
        d、应用场景：
            ①子程序的调用：在主程序进入子程序前，会先将下一个指令的地址存到堆栈中，
              知道子程序执行完成再将地址从栈中取出来，回到原来的程序中。
            ②处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，还会将参数、局部变量等数据存入堆栈中。
            ③表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)
            ④二叉树的遍历
            ⑤图形的深度优先(depth——first)搜索法。
        e、思路：
            ①使用数组来模拟栈
            ②定义一个top 来表示栈顶，初始化为-1
            ③栈空：top == -1
            ④栈满：top == maxSize - 1
            ⑤入栈操作，当有数据入栈时，top++；stack[top] = data
            ⑥出栈操作，当有数据出栈时，int value = stack[top]；top--；return value
        f、使用栈完成(中缀)表达式的计算思路
             ①先创建两个栈：数栈(存放数字)、符号栈(存放运算符)
             ②通过一个index值(索引),来遍历我们的表达式
             ③如果我们发现扫描到的是一个数字就直接入数栈
                 1）、断是否为表达式的最后一个字符
                    是：直接入数栈
                    否：再扫后一位判断是否为多位数字
                        是：做多位数字符串拼接
                        否：直接入数栈，并且清空多位数拼接符
             ④如果扫描到的是符号：
                 1）、运算符
                     一、符号栈顶元素为左括号：运算符直接入符号栈
                     二、符号栈顶元素为运算符：
                        I、如果当前运算符的优先级 <= 栈中的运算符，就需要从数栈中弹出两个数字，
                           再从符号栈中pop出一个符号，进行运算得到结果再push数栈，然后将当前运算符push符号栈。
                        II、如果当前运算符的优先级 > 栈顶的运算符，就直接push符号栈。
                 2）、左括号：直接进入符号栈
                 3)、右括号：把符号栈顶元素依次出栈，数字栈依次弹出俩数字计算，结果压入数栈，直到符号栈顶是左括号为止，左括号出栈
             ⑤当表达式扫描完毕，就有顺序地从数栈和符号栈中pop出数字和运算符，并进行运算，结果再push数栈
             ⑥最后在数栈只有一个数字，就是表达式的结果
        g、中缀表达式 -> 后缀表达式
            ①创建一个符号栈、一个结果栈
            ②从头到尾扫描表达式
            ③遇到数字直接进结果栈
            ④遇到符号
                1）、遇到运算符,扫描符号栈顶元素
                    一、左括号：直接进符号栈
                    二、运算符：
                        当前运算符优先级 > 栈顶元素，当前运算符进符号栈
                        当前运算符优先级 <= 栈顶元素，栈顶元素出符号栈再进结果栈，当前运算符进符号栈(直到再次 > 栈顶运算符)
                    三、右括号：把符号栈顶元素依次出栈再进结果栈，直到弹出左括号为止
            ⑤表达式扫描完后，把符号栈栈中元素依次进入结果栈
            ⑥结果栈自底到顶依次顺序就是后缀表达式结果
		h、使用栈完成(后缀)表达式的计算思路
		    ①从左到右扫描表达式，遇到数字时，将数字压入堆栈，
		    ②遇到运算符时，弹出栈顶的两个数
		    ③用运算符对它们进行相应的运算(次顶元素和栈顶元素)，并将结果入栈；
		    ④重复上面的步骤直到表达式最右端，栈中的值就是表达式的结果
		i、使用栈完成(前缀)表达式的计算思路
		    ①从右到左扫描表达式，遇到数字将其压入堆栈
		    ②遇到运算符时，弹出栈顶的两个数
            ③用运算符对它们进行相应的运算(次顶元素和栈顶元素)，并将结果入栈；
            ④重复上面的步骤直到表达式最右端，栈中的值就是表达式的结果

    12、递归调用机制的讲解
        a、概念：递归就是方法自己调用自己，每次调用时传入不同的变量，
                 递归有助于编程者解决复杂问题，同时可以让代码变得简洁，但是会增加内存损耗(以空间换时间)。
        b、应用场景：迷宫问题(回溯)，递归(recursion)
        c、调用规则：
            ①当程序每递归执行一次时，就会开辟一个独立的空间(栈)
            ②每个空间的数据(局部变量)都是独立的，不会互相影响
            ③如果方法中使用的是引用类型(数组)，就会共享该引用类型的数据
            ④递归必须向退出递归的条件逼近，否则就是无限递归(死递归)，出现StackOverflowError
            ⑤当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，
              同时当方法执行完毕或者返回时，该方法也就执行完毕。
            ⑥每次开辟的空间都是嵌套在当前递归执行的空间内
            ⑦所有空间(栈)的执行顺序是由内到外(每个空间被执行完都会被销毁)直到最外层。
        d、可解决问题：
            ①八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题(Google编程大赛)
            ②各种算法中也会使用到递归，比如快速排序、归并排序、二分查找、分治算法等
            ③将用栈解决问题—>递归代码比较简洁

    13、算法时间复杂度
        a、事后统计
            这种方法可行，但是有两个问题：
                一、是想要对设计的算法进行性能评测，需要实际运行该程序；
                二、是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，
                    要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。
        b、事前估算
            通过分析某个算法的时间复杂度来判断哪个算法更优
        c、时间频度
            ①一个算法花费的时间与算法中语句执行次数成正比例，那个算法中语句执行次数多，它花费时间就多。
                算法中的语句执行次数称之为语句频度或者时间频度。记为T(n)
            ②在计算时间频度的时候：都是可以在庞大频度中忽略的
                常数项
                    1)、2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
                    2)、3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略
                低次项
                    1)、2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
                    2)、n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20
                系数
                    1)、随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。
                    2)、而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键
		d、时间复杂度概念：
		    ①一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，
		        若有某个辅助函数f(n)，使得当n趋于无穷大时，T(n)/f(n)的极限值为不等于零的常熟，
		        则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。
		    ②T(n)不同，但时间复杂度可能是相同。如T(n)=n^2+7n+6 与T(n)=3n^2+2n+2 它们的T(n)不同，但时间复杂度相同，都为O(n^2)。
		    ③计算时间复杂度的方法：
		        1）、用常数1代替运行时间中的所有加法常数  如：T(n)=n^2+7n+6——>T(n)=n^2+7n+1
		        2）、修改后的运行次数函数中，只保留最高阶项   如：T(n)=n^2+7n+1——>T(n)=1n^2
		        3）、去除最高阶项的系数    如：T(n)=1n^2——>T(n)=n^2 => O(n)=n^2
		e、常见的时间复杂度(由上到下复杂度依次增大)
		    ①常熟阶——O(1)
		        ——无论代码执行了多少行，只要没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)
		    ②对数阶——O(log2n)
		        ——在while循环里面，每次都将i*2，假设while循环了x次之后i>n了，结束了while循环。
		            也就是说(i*2)^x=n ——> 2^x=n ——> x=log2n ——> i^log2n ——> O(log2n)
		        代码：
		            int i = 1;
		            int n = 1024;
		            int x = 0;
		            while(i<n){
		                i = i * 2
		                x ++;
		            }

		    ③线性阶——O(n)
		        ——for 循环里面的代码会在执行n 遍，因此它消耗的时间是随着n的变化而变化的——>O(n)
		        代码：
		            int n = 0;
		            for(int i=0; i<n; i++){
		                n += i;
		            }

		    ④线性对数阶——O(nlog2n)
		        ——for 循环n次 ②
		        代码：
		            int i = 1;
                    int n = 1024;
                    int x = 0;
		            for(int i=0; i<n; i++){
                        while(i<n){
                            i = i * 2
                            x ++;
                        }
                    }

		    ⑤平方阶——O(n^2)
		        ——双层for循环n次的遍历嵌套使用
		        代码：
		            int n = 0;
                    for(int i=0; i<n; i++){
                        for(int j=0; j<n; j++){
                            n += j;
                        }
                        n += i;
                    }

		    ⑥立方阶——O(n^3)
		        ——三层for循环n次的遍历嵌套使用
                代码：
                int n = 0;
                for(int i=0; i<n; i++){
                    for(int j=0; j<n; j++){
                        for(int z=0; z<n; z++){
                            n += z;
                        }
                        n += j;
                    }
                    n += i;
                }

		    ⑦k次方阶——O(n^k)
		        ——k层for循环n次的遍历嵌套使用
		        代码：
		            int n = 0;
                    for(int i=0; i<n; i++){
                        for(int j=0; j<n; j++){
                            .....
                            for(int z=0; z<n; z++){
                                n += z;
                            }
                            n += j;
                        }
                        n += i;
                    }
		    ⑧指数阶O(2^n)
		        ——n层for循环2次的遍历嵌套使用
		        代码：
		            int n = 0;
                    for(int i=0; i<2; i++){
                        for(int j=0; j<2; j++){
                            .....
                            for(int z=0; z<2; z++){
                                n += z;
                            }
                            n += j;
                        }
                        n += i;
                    }
		f、平均时间复杂度和最坏时间复杂度
		    ①平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该运算的运行时间。
		    ②最坏情况下的时间复杂度称最坏时间复杂度，一般讨论的时间复杂度均是最坏情况下的时间复杂度。
		      这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，
		      这就保证了算法的运行时间不会比最坏情况更长。
		    ③平均时间复杂度和最坏时间复杂度是否一致，和算法有关。

	14、算法的空间复杂度简介
	    a、类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所消耗的存储空间，
	       它也是问题规模 n 的函数。
	    b、空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。
	       有的算法需要占用的临时工作单元与解决问题的规模 n 有关，它随着 n 的增大而增大，
	       当n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法，基数排序就属于这种情况。
	    c、在做算法分析时，主要讨论的是时间复杂度。从用户体验上看，更看重的是程序执行速度。
	       一些缓存产品(Redis、memcache)和算法(基数排序)本质就是以空间换时间。
				
	15、排序算法
        a、介绍：排序是将一组数据，按照指定的顺序进行排序的过程
        b、分类：
            ①内部排序：指的是将需要处理的所有数据都加载到内部存储器(内存)中进行排序
                1）、插入排序：直接插入排序、希尔排序(插入排序优化版)
                2）、选择排序：简单选择排序、堆排序
                3）、交换排序：冒泡排序、快速排序
                4）、归并排序
                5）、基数排序
            ②外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储(文件磁盘)进行
				
	16、冒泡排序
	    a、概念：冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,
	       依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。
	    b、优化描述：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，
	       因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)
	    c、排序规则：
	        ①一共进行数组长度-1 次大的循环
	        ②每一趟排序的次数都在逐渐减少
	        ③如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，这个就是优化。
	    d、代码：
            public static int[] bubbleSort(int[] arr){
                int temp = 0;   // 辅助遍历
                boolean flag = false;   // 标识变量，标识是否进行交换(用于优化算法)
                // 冒泡排序的时间复杂度O(n^2)
                // ①一共进行数组长度-1 次大的循环
                for (int i=0; i<arr.length-1; i++){    // 执行数组.length - 1 趟
                    // ②每一趟排序的次数都在逐渐减少
                    for (int j=0; j<arr.length-1-i; j++){   // 每一趟比较的次数
                        if (arr[j] > arr[j+1]){ // 指定冒泡的规则
                            temp = arr[j+1];
                            arr[j+1] = arr[j];
                            arr[j] = temp;
                            flag = true;
                        }
                    }
                    // ③如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，这个就是优化。
                    if (flag == false){ // 证明数组元素没有发生交换位置
                        break;  // 跳出循环结束排序
                    } else {
                        flag = false;   // 重置flag！！！，进行下一次判断
                    }
                }
                return arr;
            }

	17、选择排序
	    a、概念：选择排序也属于内部排序，是从要排序的数据中，按指定的规则选出某一元素，
	             再依规定交换位置达到排序的目的。
	    b、思路：
	            第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，
	            第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，
	            第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，
	            …，
	            第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，
	            …,
	            第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，
	            总共通过n-1次，得到一个按排序码从小到大排列的有序序列。
	    c、说明：
	        ①选择排序一共有数组.length - 1 轮排序
	        ②每一轮排序，又是一次循环，循环的规则
	            1)、先假定当前元素为最小数
	            2)、然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标
	            3)、当遍历到数组的最后时，就得到本轮最小数和下标
	            4)、交换
	    d、代码：
	        public static int[] selectSort(int[] arr){
                // 选择排序时间复杂度是O(n^2)
                for (int i=0; i<arr.length-1; i++){
                    int minIndex = i;
                    int min = arr[i];
                    for (int j=i+1; j<arr.length; j++){
                        if (min > arr[j]){  // 说明假定的最小值，并不是最小
                            min = arr[j];   // 重置min
                            minIndex = j;   // 重置minIndex
                        }
                    }
                    // 将最小值放置在arr[0]的位置，即交换
                    if (minIndex != i){
                        arr[minIndex] = arr[i];
                        arr[i] = min;
                    }
                }
                return arr;
            }

	18、插入排序
	    a、思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，
	             无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序
	             码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
        b、代码：
            public static int[] insertSort(int[] arr){

                int insertVal = 0;     // 需要插入的元素
                int insertIndex = 0;    // 插入位
                for (int i=1; i<arr.length; i++){
                    insertVal = arr[i];
                    insertIndex = i - 1;
                    // insertIndex >= 0 插入位必须在数组范围
                    // insertVal < arr[insertIndex]  排序规则：从小到大——把后面小的插到前面
                    // insertVal > arr[insertIndex]  排序规则：从大到小——把后面大的插到前面
                    while (insertIndex >= 0 && insertVal < arr[insertIndex]){
                        arr[insertIndex + 1] = arr[insertIndex];
                        insertIndex --; // 依次往前面移动
                    }
                    if (insertIndex + 1 != i){  // 说明插入位不在有序列表中
                        arr[insertIndex + 1] = insertVal;   // 把待插入元素插入到正确位置
                    }
                }
                return null;
            }
				
	19、希尔排序：
	    a、概念：希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。
		b、思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，
		        每组包含的关键词越来越多，当增量减到1时，整个文件恰好被分成一组，算法终止。
		c、交换法
		    public static int[] shellSort1(int[] arr) {
                int temp = 0;   // 交换中间件
                for (int gap = arr.length / 2; gap > 0; gap /= 2) { // gap 为分组步长(增量)
                    for (int i = gap; i < arr.length; i++) {    // 遍历每一个分组
                        for (int j = i - gap; j >= 0; j -= gap) {   // 分组元素遍历
                            // arr[j] > arr[j + gap] 排序规则：从小到大
                            // arr[j] > arr[j + gap] 排序规则：从大到小
                            if (arr[j] > arr[j + gap]) {    // 分组元素间比较
                                temp = arr[j];
                                arr[j] = arr[j + gap];
                                arr[j + gap] = temp;
                            }
                        }
                    }
                }
                return arr;
            }
        d、移位法
            public static int[] shellSort2(int[] arr){
                int insertVal = 0;     // 需要插入的元素
                int insertIndex = 0;    // 插入位
                for (int gap = arr.length / 2; gap > 0; gap /= 2) { // gap 为分组步长(增量)
                    for (int i = gap; i < arr.length; i++) {    // 遍历每一个分组
                        insertIndex = i;
                        insertVal = arr[insertIndex];
                        if (arr[insertIndex] < arr[insertIndex - gap]){
                            while (insertIndex - gap >= 0 && insertVal < arr[insertIndex - gap]){
                                arr[insertIndex] = arr[insertIndex - gap];
                                insertIndex -= gap; // 依次往前面移动
                            }
                            arr[insertIndex] = insertVal;   // 把待插入元素插入到正确位置
                        }
                    }
                }
                return arr;
            }
	
	20、快速排序
	    a、概念：是对冒泡排序的改进
	    b、思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据逗比另一部分的所有数据都要小，
	       然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据编程有序序列。
	    c、代码：
	        public static int[] quickSort(int[] arr, int left, int right){
                int l = left;   // 左下标
                int r = right;  // 右下标
                int meddle = (l + r) / 2;
                int pivot = arr[meddle];    // 中间元素
                int temp = 0;   // 辅助变量，用于值交换。
                while (l < r){
                    while (arr[l] < pivot){
                        l ++;
                    }

                    while (arr[r] > pivot){
                        r --;
                    }
                    // 证明：右边的数据全部小于pivot，左边数据全部大于pivot
                    if (l >= r){
                        break;
                    }
                    // 交换值
                    temp = arr[r];
                    arr[r] = arr[l];
                    arr[l] = temp;

                    // 如果交换完后，发现这个arr[l] == pivot，r --，前移(避免死锁)
                    if (arr[l] == pivot){
                        r --;
                    }
                    // 如果交换完后，发现这个arr[r] == pivot，l ++，后移(避免死锁)
                    if (arr[r] == pivot){
                        l ++;
                    }
                }

                // 避免后面递归的时候产生栈溢出
                if (l == r){
                    l ++;
                    r --;
                }
                // 向左递归
                if (left < r){
                    quickSort(arr, left, r);
                }
                // 向右递归
                if (right > l){
                    quickSort(arr, l, right);
                }
                return arr;
            }
	
	21、归并排序
	    a、概念：利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)
	             成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
        b、思想：
            1）分过程：可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现
                      （也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。
            2、治过程：再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，
                       要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]
	    c、代码：
	        // 分+合的方法
            public static void mergeSort(int[] arr, int left, int right, int[] temp){
                if (left < right){
                    int mid = (left + right) / 2;
                    // 向左递归进行分解
                    mergeSort(arr, left, mid, temp);
                    // 向右递归进行分解
                    mergeSort(arr, mid + 1, right, temp);
                    // 合并
                    merge(arr, left, mid, right, temp);
                }
            }

            // 合并的方法
            public static int[] merge(int[] arr, int left, int mid, int right, int[] temp){
                int l = left;   // 左边有序列表的索引
                int r = mid + 1;    // 右边有序列表的索引
                int t = 0;  // temp 数组的当前索引

                /**
                 * 第一步：
                 *      1、先把左右两边(有序)的数据按照排序规则填充到temp 数组
                 *      2、直到左右两边(有序)列表，有一边的数据处理完毕
                 */
                while (l <= mid && r <= right){
                    // arr[l] <= arr[r] 排序规则(从小到大)
                    if (arr[l] <= arr[r]){
                        temp[t] = arr[l];   // 左边小，就把左边的元素填充到temp
                        t ++;
                        l ++;
                    } else {
                        temp[t] = arr[r];   // 右边边小，就把右边的元素填充到temp
                        t ++;
                        r ++;
                    }
                }

                /**
                 * 第二步：
                 *      1、把有剩余的一边的数据依照顺序全部填充到temp 中
                 */
                while (l <= mid){   // 左边列表还有元素
                    temp[t] = arr[l];   // 充填到temp
                    t ++;
                    l ++;
                }
                while (r <= right){     // 右边列表还有元素
                    temp[t] = arr[r];   // 充填到temp
                    t ++;
                    r ++;
                }

                /**
                 * 第三步：
                 *      1、将temp数组的元素拷贝到arr
                 *      2、注意：并不是每次都拷贝所有元素
                 */
                t = 0;
                int tempLeft = left;
                while (tempLeft <= right){
                    arr[tempLeft] = temp[t];
                    t ++;
                    tempLeft ++;
                }
                return arr;
            }

	22、基数排序
	    a、概念：基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或（bin sort）
	            顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序作用。是桶排序的扩展
	    b、特点：基数排序法是属于稳定性的排序，基数排序是效率高的稳定性排序算法
        c、思想：
            ①将整数按位数切割成不同的数字，然后按每个位数分别比较
            ②将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。
              这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。
        d、说明：
            ①基数排序是对传统桶排序的扩展，速度很快.
            ②基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。
            ③基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，
              这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，
              r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]
            ④有负数的数组，我们不用基数排序来进行排序, 如果要支持负数

    23、线性查找
        a、就是在一个列表里面直接遍历一遍找到那个需要的数据

    24、二分查找
        a、思想
            1)、首先确定该数租的中间下标：mid = (0 + arr.length) / 2
            2)、然后让需要查找的数：findVal 和 arr[mid] 比较
                2.1、findVal > arr[mid]，说明要查找的数在mid 的右边，因此需要递归向右查找
                2.2、findVal < arr[mid]，说明要查找的数在mid 的左边，因此需要递归向左查找
                2.3、findVal == arr[mid]，说明当前mid 就是要找的数
            3)、结束递归、
                3.1、找到就结束
                3.2、递归完整个数组，仍然没有找到findVal，也需要结束递归，当left > right 就需要退出
