一、数据结构
    简洁：
        a、数据：是描述客观事物的数和字符的集合
        b、数据项：是具有独立含义的数据最小单位，也称为字段或域
        c、数据对象：是指性质相同的数据元素的集合，它是数据的一个子集
        d、数据结构：是指所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定的关系的数据元素的集合。
            1）、逻辑结构
            2）、存储结构
        e、数据运算：施加在数据上的操作
        f、逻辑结构：是指数据元素之间的逻辑关系的整体，通常是由实际的需要中提炼出来的。
            1）、集合：是指数据元素之间除了“同属于一个集合”的关系以外别无其他关系。
            2）、线性结构：是指该结构中的数据元素之间存在一对一的关系，除了开始元素和终端元素都是唯一的，
                          其他元素都是有且仅有一个前驱元素，有且仅有一个后继元素。
            3）、树形结构：是指该结构中数据元素之间存在一对多的关系。其特点是除了开始元素以外，每个元素有且仅有
                          一个前驱元素，有一个或多个后继元素。
            4）、图形结构：是指该结构中的数据元素之间存在多对多的关系。其特点是每个元素的前驱元素和后继元素的
                          个数都是可以任意的。因此，图形结构也没有开始元素和终端元素。
        g、存储结构：数据元素及其关系在计算机上存储器中的存储表示，也称为数据的物理结构，计算机中的存储实现(映像)
            1）、顺序存储结构：是一组连续的存储单元存放所有数据元素，就是按照数据元素之间的逻辑关系存储到内存空间中。
                ①优点：存储空间利用率高(不需要额外的存储逻辑关系)、查找数据元素快(直接根据其逻辑序号找到存储空间上对应的序号)
                ②缺点：不便于数据元素的修改和删除，因为这两种操作都需要移动数据元素的存储单元。
            2）、链式存储结构：把每一个数据元素按照节点的方式拼接成一条链表式的存储空间，只需要给每个节点分配空间，而且互相独立。
                              所有节点不一定是连续的，不需要占用一整块空间，给每个节点附加一个指针域用于存放相邻节点的存储地址。
                ①优点：便于数据修改(不用移动内存空间)、对元素插入或删除操作时仅需修改相应的节点指针域，不比移动节点。
                ②缺点：存储空间利用率低，因为分配给元素的存储单元有一部分被用来存储节点之间的逻辑关系。由于链式存储不一定是有顺序的，
                        所以查找的时候不能随机查找，需要从头到尾遍历一遍链表。
            3）、索引存储结构：是指在存储数据元素信息的同时还创建附加的索引表。存储数据信息的表称为主数据表，而存储索引的表称为索引表。
                              先通过关键字查找索引表的关键字地址，然后再通过该地址到主数据表查找对应数据
                ①优点：查找效率高
                ②缺点：需要建立索引表，从而增加了空间开销。
            4）、哈希(散列)存储结构：根据元素的关键字通过哈希(散列)函数计算出一个值作为其在存储空间上的存储地址。
                ①优点：查找速度快，只要给出对应的查找关键字就可以立即通过哈希函数计算出对应的存储地址。
                ②缺点：不存储元素之间的逻辑关系，所以哈希存储结构一般只合适于快速查找和插入元素的场合。
        h、数据运算：是指对数据实施的一种操作。最常用的运算有索引、插入、删除、更新和排序等。
            1）、运算定义：是运算功能的描述，是抽象的，是基于逻辑结构的。
            2）、运算实现：是程序员完成运算的实现算法，是具体的，是基于存储结构的。


	1、线性结构：顺序存储结构(列表)和链式存储结构(链表)，数据元素之间具有一对一的线性关系
		①列表：存储的元素具有具有连续性
		②链表：不一定具有连续性(有可能在中间插入一个节点)
		③常见类型：数组、链表、栈和队列
		
	2、非线性结构包括：数据元素之间不一定是一对一的关系，也有可能是一对多的关系
		①常见类型：二维数组、多维数组、广义表、树结构、图结构
		
	3、稀疏数组：
		①结构：第一行记录着该对应矩阵的的结构(行、列、值——非零的个数)的情况
		②作用：第二行起就是就是记录矩阵的非零值的坐标(在矩阵中的行、列的位置)和值
	
	4、二维数组转稀疏数组的思路
		①遍历二维数组，得到有效数据(非零值)的个数sum
		②根据sum 和二维数组的根索引就可以创建稀疏数组sparseArr[sum+1][3]
		③将二维数组的有效数据的坐标(行、列)和值存入到稀疏数组中
	
	5、稀疏数组转二维数组的思路
		①先读取稀疏数组的第一行，根据第一行的数据(前面两列代表的是二维数组的行、列大小)，创建原始的二维数组
		②再从第二行开始读取稀疏数组的数据并根据指明的行、列、值写入到二维数组对应的位置即可
		
	6、队列：是一个有序列表，可以用数组或是链表来实现
		①规则：遵循先入先出的原则。即，先存入对列的数据，要先被取出，后存入队列的数据要被后取出。
		②结构：因为独立的输出输入分别是从前后端来处理，因此需要两个变量front(队首)、rear(队尾)，
			   分别记录队列前后端的下标，front会随着数据输出而变化，而rear则是随着数据的输入而变化。
		③front：当数据出队的时候自增1，数据入队不变化
		④rear：当数据入队的时候自增1，数据出队不变化
	
	7、使用数组模拟环形队列的思路分析
		a、front(初始值0)变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。
		b、rear(初始值0)变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置。因为希望空出一个空间作为约定。
		c、当队列满时，条件是：(rear + 1) % maxSize == front【满】
		d、当队列为空时的条件是：rear == front【空】
		e、当我们这样分析，队列中有效的数据的个数：(rear + maxSeize - front) % maxSize
		f、在上面几个条件下就可以在原来的队列进行改造得到一个环形队列。
	
	8、单向链表链表(Linked List)
		a、链表是以节点的方式来存储
		b、每个节点包含data域，next域：指向下一个节点
		c、链表的各个节点不一定是连续的存储
		d、链表分带头节点的链表和没有头结点的链表，根据实际需求来确定
		e、业务：把水浒传里的人物采用链表的方式展现出来
		f、节点结构
		    class Hero{ // 数据对象
		        int no;
                String name;
                String nickName;
		    }
			class Node{ // 节点
				Here data;
				HeroNode next;
			}
		g、需求：
			添加（创建）
				1、先创建一个head 头结点，作用就是表示单链表的头
				2、后面我们每添加一个节点，就直接赋值给链表最后节点的next域
			遍历：
				1、通过一个辅助遍历，帮助遍历整个链表
		h、缺点：
		    1、查找或遍历链表的方向只有一个
		    2、单向链表不能自我删除，只能依靠辅助节点

	9、双向链表
	    a、结构：相比于单向链表指向下一个节点next域，双向链表的节点多了个指向前一个节点的pre域
        b、分析：
            1、遍历方向和单向链表一样，只是可以向前查找也可以向后查找
            2、添加(默认添加到双向链表的最后)
				①先找到双向节点的最后一个节点
				②temp.next = newNode
				③newNode.pre = temp
			3、修改思路和原来的单向链表一样
			4、删除
			    ①因为是双向链表，因此我们可以实现直接自我删除某个节点
				②直接找到要删除的这个节点，比如temp
				③temp.pre.next = temp.next
				④temp.next.pre = temp.next(注意：若删除的是最后一个节点会报空指针异常)

	10、单向环形链表
	    a、约瑟夫问题：设编号为1,2,3....n个人围坐成一圈，约定编号为k(1<=k<=n)的人开始报数，数到m的那个人出列，
	       它的下一位又从1开始数，数到m的那个人又出列，依次类推，直到所有人都出列位置，由此产生的一个出队编号的序列。
	        如：
	            n = 10  总数10人
	            k = 1 从1号开始数数
	            m = 3   每次数到3的人出队
	    b、单向链表实现：用一个不带头结点的循环链表来处理josephu 问题
	        ①先构成一个有n个节点的单循环链表
	        ②然后由k节点开始计数，记到m时，对应节点从链表中删除
	        ③然后再从被删除节点的下一个节点又从1开始计数到m又删除
	        ④依次循环直到节点从链表中全部删除算法结束
	    c、构建单向的环形链表思路
	        ①先创建第一个节点，让first指向该节点，并形成环形
	        ②后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表中即可
	    d、遍历环形链表
	        ①先让一个辅助指针(变量)，指向first节点
	        ②然后通过一个while循环遍历该环形链表即可 curBoy.next == first

    11、栈(stack)
        a、栈是一个先进后出(FILO-first In Last Out)的有序列表
        b、栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。
           允许插入和删除的一端，为变化的一端，称为栈顶(top),另一端为固定的一端，称为栈底(bottom)。
        c、根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，
            最后放入的元素最先删除，最先放入的元素最后删除。
        d、应用场景：
            ①子程序的调用：在主程序进入子程序前，会先将下一个指令的地址存到堆栈中，
              知道子程序执行完成再将地址从栈中取出来，回到原来的程序中。
            ②处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，还会将参数、局部变量等数据存入堆栈中。
            ③表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)
            ④二叉树的遍历
            ⑤图形的深度优先(depth——first)搜索法。
        e、思路：
            ①使用数组来模拟栈
            ②定义一个top 来表示栈顶，初始化为-1
            ③栈空：top == -1
            ④栈满：top == maxSize - 1
            ⑤入栈操作，当有数据入栈时，top++；stack[top] = data
            ⑥出栈操作，当有数据出栈时，int value = stack[top]；top--；return value
        f、使用栈完成(中缀)表达式的计算思路
             ①先创建两个栈：数栈(存放数字)、符号栈(存放运算符)
             ②通过一个index值(索引),来遍历我们的表达式
             ③如果我们发现扫描到的是一个数字就直接入数栈
                 1）、断是否为表达式的最后一个字符
                    是：直接入数栈
                    否：再扫后一位判断是否为多位数字
                        是：做多位数字符串拼接
                        否：直接入数栈，并且清空多位数拼接符
             ④如果扫描到的是符号：
                 1）、运算符
                     一、符号栈顶元素为左括号：运算符直接入符号栈
                     二、符号栈顶元素为运算符：
                        I、如果当前运算符的优先级 <= 栈中的运算符，就需要从数栈中弹出两个数字，
                           再从符号栈中pop出一个符号，进行运算得到结果再push数栈，然后将当前运算符push符号栈。
                        II、如果当前运算符的优先级 > 栈顶的运算符，就直接push符号栈。
                 2）、左括号：直接进入符号栈
                 3)、右括号：把符号栈顶元素依次出栈，数字栈依次弹出俩数字计算，结果压入数栈，直到符号栈顶是左括号为止，左括号出栈
             ⑤当表达式扫描完毕，就有顺序地从数栈和符号栈中pop出数字和运算符，并进行运算，结果再push数栈
             ⑥最后在数栈只有一个数字，就是表达式的结果
        g、中缀表达式 -> 后缀表达式
            ①创建一个符号栈、一个结果栈
            ②从头到尾扫描表达式
            ③遇到数字直接进结果栈
            ④遇到符号
                1）、遇到运算符,扫描符号栈顶元素
                    一、左括号：直接进符号栈
                    二、运算符：
                        当前运算符优先级 > 栈顶元素，当前运算符进符号栈
                        当前运算符优先级 <= 栈顶元素，栈顶元素出符号栈再进结果栈，当前运算符进符号栈(直到再次 > 栈顶运算符)
                    三、右括号：把符号栈顶元素依次出栈再进结果栈，直到弹出左括号为止
            ⑤表达式扫描完后，把符号栈栈中元素依次进入结果栈
            ⑥结果栈自底到顶依次顺序就是后缀表达式结果
		h、使用栈完成(后缀)表达式的计算思路
		    ①从左到右扫描表达式，遇到数字时，将数字压入堆栈，
		    ②遇到运算符时，弹出栈顶的两个数
		    ③用运算符对它们进行相应的运算(次顶元素和栈顶元素)，并将结果入栈；
		    ④重复上面的步骤直到表达式最右端，栈中的值就是表达式的结果
		i、使用栈完成(前缀)表达式的计算思路
		    ①从右到左扫描表达式，遇到数字将其压入堆栈
		    ②遇到运算符时，弹出栈顶的两个数
            ③用运算符对它们进行相应的运算(次顶元素和栈顶元素)，并将结果入栈；
            ④重复上面的步骤直到表达式最右端，栈中的值就是表达式的结果

    12、递归调用机制的讲解
        a、概念：递归就是方法自己调用自己，每次调用时传入不同的变量，
                 递归有助于编程者解决复杂问题，同时可以让代码变得简洁，但是会增加内存损耗(以空间换时间)。
        b、应用场景：迷宫问题(回溯)，递归(recursion)
        c、调用规则：
            ①当程序每递归执行一次时，就会开辟一个独立的空间(栈)
            ②每个空间的数据(局部变量)都是独立的，不会互相影响
            ③如果方法中使用的是引用类型(数组)，就会共享该引用类型的数据
            ④递归必须向退出递归的条件逼近，否则就是无限递归(死递归)，出现StackOverflowError
            ⑤当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，
              同时当方法执行完毕或者返回时，该方法也就执行完毕。
            ⑥每次开辟的空间都是嵌套在当前递归执行的空间内
            ⑦所有空间(栈)的执行顺序是由内到外(每个空间被执行完都会被销毁)直到最外层。
        d、可解决问题：
            ①八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题(Google编程大赛)
            ②各种算法中也会使用到递归，比如快速排序、归并排序、二分查找、分治算法等
            ③将用栈解决问题—>递归代码比较简洁

    13、算法时间复杂度
        a、事后统计
            这种方法可行，但是有两个问题：
                一、是想要对设计的算法进行性能评测，需要实际运行该程序；
                二、是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，
                    要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。
        b、事前估算
            通过分析某个算法的时间复杂度来判断哪个算法更优
        c、时间频度
            ①一个算法花费的时间与算法中语句执行次数成正比例，那个算法中语句执行次数多，它花费时间就多。
                算法中的语句执行次数称之为语句频度或者时间频度。记为T(n)
            ②在计算时间频度的时候：都是可以在庞大频度中忽略的
                常数项
                    1)、2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
                    2)、3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略
                低次项
                    1)、2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
                    2)、n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20
                系数
                    1)、随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。
                    2)、而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键
		d、时间复杂度概念：
		    ①一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，
		        若有某个辅助函数f(n)，使得当n趋于无穷大时，T(n)/f(n)的极限值为不等于零的常熟，
		        则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。
		    ②T(n)不同，但时间复杂度可能是相同。如T(n)=n^2+7n+6 与T(n)=3n^2+2n+2 它们的T(n)不同，但时间复杂度相同，都为O(n^2)。
		    ③计算时间复杂度的方法：
		        1）、用常数1代替运行时间中的所有加法常数  如：T(n)=n^2+7n+6——>T(n)=n^2+7n+1
		        2）、修改后的运行次数函数中，只保留最高阶项   如：T(n)=n^2+7n+1——>T(n)=1n^2
		        3）、去除最高阶项的系数    如：T(n)=1n^2——>T(n)=n^2 => O(n)=n^2
		e、常见的时间复杂度(由上到下复杂度依次增大)
		    ①常熟阶——O(1)
		        ——无论代码执行了多少行，只要没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)
		    ②对数阶——O(log2n)
		        ——在while循环里面，每次都将i*2，假设while循环了x次之后i>n了，结束了while循环。
		            也就是说(i*2)^x=n ——> 2^x=n ——> x=log2n ——> i^log2n ——> O(log2n)
		        代码：
		            int i = 1;
		            int n = 1024;
		            int x = 0;
		            while(i<n){
		                i = i * 2
		                x ++;
		            }

		    ③线性阶——O(n)
		        ——for 循环里面的代码会在执行n 遍，因此它消耗的时间是随着n的变化而变化的——>O(n)
		        代码：
		            int n = 0;
		            for(int i=0; i<n; i++){
		                n += i;
		            }

		    ④线性对数阶——O(nlog2n)
		        ——for 循环n次 ②
		        代码：
		            int i = 1;
                    int n = 1024;
                    int x = 0;
		            for(int i=0; i<n; i++){
                        while(i<n){
                            i = i * 2
                            x ++;
                        }
                    }

		    ⑤平方阶——O(n^2)
		        ——双层for循环n次的遍历嵌套使用
		        代码：
		            int n = 0;
                    for(int i=0; i<n; i++){
                        for(int j=0; j<n; j++){
                            n += j;
                        }
                        n += i;
                    }

		    ⑥立方阶——O(n^3)
		        ——三层for循环n次的遍历嵌套使用
                代码：
                int n = 0;
                for(int i=0; i<n; i++){
                    for(int j=0; j<n; j++){
                        for(int z=0; z<n; z++){
                            n += z;
                        }
                        n += j;
                    }
                    n += i;
                }

		    ⑦k次方阶——O(n^k)
		        ——k层for循环n次的遍历嵌套使用
		        代码：
		            int n = 0;
                    for(int i=0; i<n; i++){
                        for(int j=0; j<n; j++){
                            .....
                            for(int z=0; z<n; z++){
                                n += z;
                            }
                            n += j;
                        }
                        n += i;
                    }
		    ⑧指数阶O(2^n)
		        ——n层for循环2次的遍历嵌套使用
		        代码：
		            int n = 0;
                    for(int i=0; i<2; i++){
                        for(int j=0; j<2; j++){
                            .....
                            for(int z=0; z<2; z++){
                                n += z;
                            }
                            n += j;
                        }
                        n += i;
                    }
		f、平均时间复杂度和最坏时间复杂度
		    ①平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该运算的运行时间。
		    ②最坏情况下的时间复杂度称最坏时间复杂度，一般讨论的时间复杂度均是最坏情况下的时间复杂度。
		      这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，
		      这就保证了算法的运行时间不会比最坏情况更长。
		    ③平均时间复杂度和最坏时间复杂度是否一致，和算法有关。

	14、算法的空间复杂度简介
	    a、类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所消耗的存储空间，
	       它也是问题规模 n 的函数。
	    b、空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。
	       有的算法需要占用的临时工作单元与解决问题的规模 n 有关，它随着 n 的增大而增大，
	       当n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法，基数排序就属于这种情况。
	    c、在做算法分析时，主要讨论的是时间复杂度。从用户体验上看，更看重的是程序执行速度。
	       一些缓存产品(Redis、memcache)和算法(基数排序)本质就是以空间换时间。
				
	15、排序算法
        a、介绍：排序是将一组数据，按照指定的顺序进行排序的过程
        b、分类：
            ①内部排序：指的是将需要处理的所有数据都加载到内部存储器(内存)中进行排序
                1）、插入排序：直接插入排序、希尔排序(插入排序优化版)
                2）、选择排序：简单选择排序、堆排序
                3）、交换排序：冒泡排序、快速排序
                4）、归并排序
                5）、基数排序
            ②外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储(文件磁盘)进行
				
	16、冒泡排序
	    a、概念：冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,
	       依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。
	    b、优化描述：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，
	       因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)
	    c、排序规则：
	        ①一共进行数组长度-1 次大的循环
	        ②每一趟排序的次数都在逐渐减少
	        ③如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，这个就是优化。
	    d、代码：
            public static int[] bubbleSort(int[] arr){
                int temp = 0;   // 辅助遍历
                boolean flag = false;   // 标识变量，标识是否进行交换(用于优化算法)
                // 冒泡排序的时间复杂度O(n^2)
                // ①一共进行数组长度-1 次大的循环
                for (int i=0; i<arr.length-1; i++){    // 执行数组.length - 1 趟
                    // ②每一趟排序的次数都在逐渐减少
                    for (int j=0; j<arr.length-1-i; j++){   // 每一趟比较的次数
                        if (arr[j] > arr[j+1]){ // 指定冒泡的规则
                            temp = arr[j+1];
                            arr[j+1] = arr[j];
                            arr[j] = temp;
                            flag = true;
                        }
                    }
                    // ③如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，这个就是优化。
                    if (flag == false){ // 证明数组元素没有发生交换位置
                        break;  // 跳出循环结束排序
                    } else {
                        flag = false;   // 重置flag！！！，进行下一次判断
                    }
                }
                return arr;
            }

	17、选择排序
	    a、概念：选择排序也属于内部排序，是从要排序的数据中，按指定的规则选出某一元素，
	             再依规定交换位置达到排序的目的。
	    b、思路：
	            第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，
	            第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，
	            第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，
	            …，
	            第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，
	            …,
	            第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，
	            总共通过n-1次，得到一个按排序码从小到大排列的有序序列。
	    c、说明：
	        ①选择排序一共有数组.length - 1 轮排序
	        ②每一轮排序，又是一次循环，循环的规则
	            1)、先假定当前元素为最小数
	            2)、然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标
	            3)、当遍历到数组的最后时，就得到本轮最小数和下标
	            4)、交换
	    d、代码：
	        public static int[] selectSort(int[] arr){
                // 选择排序时间复杂度是O(n^2)
                for (int i=0; i<arr.length-1; i++){
                    int minIndex = i;
                    int min = arr[i];
                    for (int j=i+1; j<arr.length; j++){
                        if (min > arr[j]){  // 说明假定的最小值，并不是最小
                            min = arr[j];   // 重置min
                            minIndex = j;   // 重置minIndex
                        }
                    }
                    // 将最小值放置在arr[0]的位置，即交换
                    if (minIndex != i){
                        arr[minIndex] = arr[i];
                        arr[i] = min;
                    }
                }
                return arr;
            }

	18、插入排序
	    a、思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，
	             无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序
	             码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
        b、代码：
            public static int[] insertSort(int[] arr){

                int insertVal = 0;     // 需要插入的元素
                int insertIndex = 0;    // 插入位
                for (int i=1; i<arr.length; i++){
                    insertVal = arr[i];
                    insertIndex = i - 1;
                    // insertIndex >= 0 插入位必须在数组范围
                    // insertVal < arr[insertIndex]  排序规则：从小到大——把后面小的插到前面
                    // insertVal > arr[insertIndex]  排序规则：从大到小——把后面大的插到前面
                    while (insertIndex >= 0 && insertVal < arr[insertIndex]){
                        arr[insertIndex + 1] = arr[insertIndex];
                        insertIndex --; // 依次往前面移动
                    }
                    if (insertIndex + 1 != i){  // 说明插入位不在有序列表中
                        arr[insertIndex + 1] = insertVal;   // 把待插入元素插入到正确位置
                    }
                }
                return null;
            }
				
	19、希尔排序：
	    a、概念：希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。
		b、思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，
		        每组包含的关键词越来越多，当增量减到1时，整个文件恰好被分成一组，算法终止。
		c、交换法
		    public static int[] shellSort1(int[] arr) {
                int temp = 0;   // 交换中间件
                for (int gap = arr.length / 2; gap > 0; gap /= 2) { // gap 为分组步长(增量)
                    for (int i = gap; i < arr.length; i++) {    // 遍历每一个分组
                        for (int j = i - gap; j >= 0; j -= gap) {   // 分组元素遍历
                            // arr[j] > arr[j + gap] 排序规则：从小到大
                            // arr[j] > arr[j + gap] 排序规则：从大到小
                            if (arr[j] > arr[j + gap]) {    // 分组元素间比较
                                temp = arr[j];
                                arr[j] = arr[j + gap];
                                arr[j + gap] = temp;
                            }
                        }
                    }
                }
                return arr;
            }
        d、移位法
            public static int[] shellSort2(int[] arr){
                int insertVal = 0;     // 需要插入的元素
                int insertIndex = 0;    // 插入位
                for (int gap = arr.length / 2; gap > 0; gap /= 2) { // gap 为分组步长(增量)
                    for (int i = gap; i < arr.length; i++) {    // 遍历每一个分组
                        insertIndex = i;
                        insertVal = arr[insertIndex];
                        if (arr[insertIndex] < arr[insertIndex - gap]){
                            while (insertIndex - gap >= 0 && insertVal < arr[insertIndex - gap]){
                                arr[insertIndex] = arr[insertIndex - gap];
                                insertIndex -= gap; // 依次往前面移动
                            }
                            arr[insertIndex] = insertVal;   // 把待插入元素插入到正确位置
                        }
                    }
                }
                return arr;
            }
	
	20、快速排序
	    a、概念：是对冒泡排序的改进
	    b、思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据逗比另一部分的所有数据都要小，
	       然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据编程有序序列。
	    c、代码：
	        public static int[] quickSort(int[] arr, int left, int right){
                int l = left;   // 左下标
                int r = right;  // 右下标
                int meddle = (l + r) / 2;
                int pivot = arr[meddle];    // 中间元素
                int temp = 0;   // 辅助变量，用于值交换。
                while (l < r){
                    while (arr[l] < pivot){
                        l ++;
                    }

                    while (arr[r] > pivot){
                        r --;
                    }
                    // 证明：右边的数据全部小于pivot，左边数据全部大于pivot
                    if (l >= r){
                        break;
                    }
                    // 交换值
                    temp = arr[r];
                    arr[r] = arr[l];
                    arr[l] = temp;

                    // 如果交换完后，发现这个arr[l] == pivot，r --，前移(避免死锁)
                    if (arr[l] == pivot){
                        r --;
                    }
                    // 如果交换完后，发现这个arr[r] == pivot，l ++，后移(避免死锁)
                    if (arr[r] == pivot){
                        l ++;
                    }
                }

                // 避免后面递归的时候产生栈溢出
                if (l == r){
                    l ++;
                    r --;
                }
                // 向左递归
                if (left < r){
                    quickSort(arr, left, r);
                }
                // 向右递归
                if (right > l){
                    quickSort(arr, l, right);
                }
                return arr;
            }
	
	21、归并排序
	    a、概念：利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)
	             成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
        b、思想：
            1）分过程：可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现
                      （也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。
            2、治过程：再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，
                       要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]
	    c、代码：
	        // 分+合的方法
            public static void mergeSort(int[] arr, int left, int right, int[] temp){
                if (left < right){
                    int mid = (left + right) / 2;
                    // 向左递归进行分解
                    mergeSort(arr, left, mid, temp);
                    // 向右递归进行分解
                    mergeSort(arr, mid + 1, right, temp);
                    // 合并
                    merge(arr, left, mid, right, temp);
                }
            }

            // 合并的方法
            public static int[] merge(int[] arr, int left, int mid, int right, int[] temp){
                int l = left;   // 左边有序列表的索引
                int r = mid + 1;    // 右边有序列表的索引
                int t = 0;  // temp 数组的当前索引

                /**
                 * 第一步：
                 *      1、先把左右两边(有序)的数据按照排序规则填充到temp 数组
                 *      2、直到左右两边(有序)列表，有一边的数据处理完毕
                 */
                while (l <= mid && r <= right){
                    // arr[l] <= arr[r] 排序规则(从小到大)
                    if (arr[l] <= arr[r]){
                        temp[t] = arr[l];   // 左边小，就把左边的元素填充到temp
                        t ++;
                        l ++;
                    } else {
                        temp[t] = arr[r];   // 右边边小，就把右边的元素填充到temp
                        t ++;
                        r ++;
                    }
                }

                /**
                 * 第二步：
                 *      1、把有剩余的一边的数据依照顺序全部填充到temp 中
                 */
                while (l <= mid){   // 左边列表还有元素
                    temp[t] = arr[l];   // 充填到temp
                    t ++;
                    l ++;
                }
                while (r <= right){     // 右边列表还有元素
                    temp[t] = arr[r];   // 充填到temp
                    t ++;
                    r ++;
                }

                /**
                 * 第三步：
                 *      1、将temp数组的元素拷贝到arr
                 *      2、注意：并不是每次都拷贝所有元素
                 */
                t = 0;
                int tempLeft = left;
                while (tempLeft <= right){
                    arr[tempLeft] = temp[t];
                    t ++;
                    tempLeft ++;
                }
                return arr;
            }

	22、基数排序
	    a、概念：基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或（bin sort）
	            顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序作用。是桶排序的扩展
	    b、特点：基数排序法是属于稳定性的排序，基数排序是效率高的稳定性排序算法
        c、思想：
            ①将整数按位数切割成不同的数字，然后按每个位数分别比较
            ②将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。
              这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。
        d、说明：
            ①基数排序是对传统桶排序的扩展，速度很快.
            ②基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。
            ③基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，
              这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，
              r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]
            ④有负数的数组，我们不用基数排序来进行排序, 如果要支持负数

    23、线性查找
        a、就是在一个列表里面直接遍历一遍找到那个需要的数据
        b、代码：
            public static int seqSearch(int[] arr, int value){
                for (int i=0; i<arr.length; i++){
                    if (value == arr[i]){
                        return arr[i];
                    }
                }
                return -1;
            }

    24、二分查找
        a、思想
            1)、首先确定该数租的中间下标：mid = (0 + arr.length) / 2
            2)、然后让需要查找的数：findVal 和 arr[mid] 比较
                2.1、findVal > arr[mid]，说明要查找的数在mid 的右边，因此需要递归向右查找
                2.2、findVal < arr[mid]，说明要查找的数在mid 的左边，因此需要递归向左查找
                2.3、findVal == arr[mid]，说明当前mid 就是要找的数
            3)、结束递归、
                3.1、找到就结束
                3.2、递归完整个数组，仍然没有找到findVal，也需要结束递归，当left > right 就需要退出
        b、代码：
            public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
                int mid = (left + right) / 2;
                List<Integer> list = new ArrayList<>();
                if (left > right) {  // 设置查找范围
                    return new ArrayList<>();
                }
                if (findVal > arr[mid]){    // 要查找的数在左边
                    return binarySearch2(arr, mid, right, findVal);
                } else if (findVal < arr[mid]){     // 要查找的数在右边
                    return binarySearch2(arr, left, mid, findVal);
                } else {
                    // 找到的当前mid
                    list.add(mid);
                    // mid 左边查找
                    int temp = mid - 1;
                    while (true){
                        // 在数组左边界之内，匹配查找值
                        if (temp < 0 || arr[temp] != findVal){
                            break;
                        }
                        list.add(temp);
                        temp --;
                    }
                    // mid 右边查找
                    temp = mid + 1;
                    while (true){
                        // 在数组右边界之内，匹配查找值
                        if (temp > arr.length-1 || arr[temp] != findVal){
                            break;
                        }
                        list.add(temp);
                        temp ++;
                    }
                    return list;
                }
            }

    25、差值查找
        a、概念：
            1）、差值查找算法类似于二分查找，不同的是插值查找每次自适应mid 处开始查找。
            2）、将折半查找中求mid 索引的公式，low 表示左索引，left，high 表示右索引right，key 就是要查找的值findVal
                mid = (low + high) / 2 => low + 1/2(high - low)
                    => low + (key - arr[low]) / (arr[high] - arr[low]) * (high - low)
            3）、转换成左、右索引和findVal 的公式：
                int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])
        b、应用场景：
            1）、对于数据量比较大，关键字分布比较均匀的表查找数据，采用插值查找，速度较快
            2）、关键字分布不均匀的情况下，该方法不一定比折半查找要好
        c、代码：
            public static int insertValueSearch(int[] arr, int left, int right, int findVal){
                // findVal < arr[0] || findVal > arr[arr.length-1]：规定查找范围在数组内
                if (left > right || findVal < arr[0] || findVal > arr[arr.length-1]){
                    return -1;
                }
                // 自适应查找mid
                int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
                int midVal = arr[mid];
                // 在中间值的左边
                if (findVal > midVal){
                    insertValueSearch(arr, left, mid - 1, findVal);
                }
                // 在中间值的右边
                if (findVal < midVal){
                    insertValueSearch(arr, mid + 1, right, findVal);
                }
                return mid;
            }

    26、斐波那契查找
        a、基本介绍
            黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。
            取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。
            这是一个神奇的数字，会带来意向不大的效果
        b、斐波那契(黄金分割法)原理
            1)、斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，
                mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1
            2）、由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1。
                 该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，
                 即如上图所示。从而中间位置为mid=low+F(k-1)-1
            3）、类似的，每一子段也可以用相同的方式分割
            4）、但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。
                 这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，
                 新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可
                    while(n>fib(k)-1)
                        k++;
        c、思想：
            1）、先把数组长度补齐到斐波那契数组元素大小(方便后面(1:0.618)切割)
            2）、利用斐波那契原理(黄金分割)找到切割点
            3）、拿切割点下标的元素与findVal比较
                arr[mid] > findVal => 在切割点右边
                    右递归
                arr[mid] < findVal => 在切割点左边
                    左递归
                arr[mid] == findVal => 找到结果
                    返回结果
            4）、判断左右边界是否合理在数组范围内
            4）、返回结果
        d、代码：
            public static int fibonacciSearch(int[] arr, int key){
                int low = 0;    // 左边界
                int high = arr.length - 1;   // 右边界
                int k = 0;  // 斐波那契分割指针f(k)
                int mid = 0;
                int[] f = fib(20);  // 斐波那契数组
                // 获取斐波那契分割数值的下标
                while (high > f[k] - 1){
                    k ++;
                }
                // 因为f[k] 可能大于 arr.length，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]
                // 多余部分可用0 补充，实际上是用arr 数组的最后元素填充
                int[] temp = Arrays.copyOf(arr, f[k]);
                // 举例：temp = {1, 8, 10, 89, 100, 1234, 0, 0} => temp = {1, 8, 10, 89, 100, 1234, 1234, 1234}
                for (int i=high+1; i<temp.length; i++){
                    temp[i] = arr[high];
                }

                // 使用while 来循环处理，找到我们的需求key
                while (low <= high){
                    /**
                     * 原理：f[k] = f[k-1] + f[k-2](斐波那契原理)
                     *      f[k] - 1 = (f[k-1] -1) + (f[k-2] - 1) + 1;
                     *      mid = low + f[k-1] - 1;
                     */
                    // 初始化切割位置
                    mid = low + f[k-1] - 1; // 相当于：当前数组长度 * 0.618
                    // 大于切割位置，说明在切割位置的后面
                    if (key > temp[mid]){
                        // 重新设定右边界
                        low = mid + 1;
                        /**
                         * 原因：新的查找数组arr 的范围(mid, f[k-2] - 1)之间
                         *      且：f[k-2] -1 = (f[k-3]-1) + (f[k-4]-1)
                         *      所以：mid = mid + f[k-3]-1 = mid + f[k-1-2] -1
                         */
                        k -= 2;
                    } else if (key < temp[mid]){
                        // 重新设置左边界
                        high = mid - 1;
                        /**
                         * 原因：新的查找数组arr 的范围(low, f[k-1] - 1)之间
                         *      且：f[k-1] = (f[k-2]-1) + (f[k-3]-1) + 1
                         *      所以：mid = low + f[k-2] -1 = f[k-1-1] -1
                         */
                        k --;
                    } else {
                        if (mid <= high){   // 返回当前mid
                            return mid;
                        } else {    // 因为超出high 部分使用arr[high]填充的
                            return high;
                        }
                    }
                }
                return -1;  // 没有找到
            }

    27、哈希表
        a、google公司的一个上机题：
            有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,
            要求查找到该员工的 所有信息.（要求: 不使用数据库,尽量节省内存,速度越快越好=>哈希表(散列)）
        b、概念：
            散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，
            它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
        c、思想：
            1）、创建一个Employee类管理员工信息
            2）、创建一个EmpNode类作为节点把Employee类封装到内部的data变量中
            3）、创建一个EmpLinkedList类作为管理EmpNode节点的链表
            4）、创建一个HashTab类作为管理多条链表的table结构

    28、树
        a、定义：有n个节点(或元素)组成的有限集合。有且仅有一个根节点，其余为子节点(n-1)。结点之间存在一对多的关系。
                其特点是除了开始元素以外，每个元素有且仅有一个前驱元素，有一个或多个后继元素。子结点之间又本身构成
                了一颗树，所以树的定义是符合递归思想的。
        b、树的基本术语
            1）、结点的度(树的度)：结点的子树个数称为节点的度，而结点的度(degree of node)的最大值称为树的度(degree of tree)。
            2）、分支结点与叶子结点：树中度不为零的结点称为非终结点/分支结点(branch)，度为零的结点称为叶子结点(leaf)，每个结点
                 的分支数就是该结点的度。
            3）、路径与路径长度：两个结点之间由其它结点形成的线路称为路径，路径长度就是这条路径途径结点数n-1
            4）、孩子结点、父结点和兄弟结点：在树中每个结点的后继结点称为其孩子节点，而其前驱节点称为其父结点，
                 同一个父结点下其他节点称为兄弟结点。
            5）、结点层次和树的高度：树中每个结点都处于相应的层次上，从根结点为第一层往后类推。树中的最大层称为树的高度。
            6）、有序树和无序树：树中的各结点的子树按照一定的次序从左到右安排，且相对次序不能随意变换称为有序树，否则为无序树。
            7）、森林：由多个互不相交的树组成的集合称为森林。如，把含有多棵子树的根结点删去了就成了森林，
                 相应地为森林接上一个根结点就成为了一棵树。
        c、数的性质
            1）、树中的结点数等于所有结点的度之和+1
            2）、度为m的树中第i层上最多有 m^(i-1) 个节点
            3）、高度为h的m次树最多有 (m^h-1)/(m-1) 个结点
            4）、具有n个结点的m次树的最小高度为[logm(n(m-1)+1)]
        d、基本运算
            1）、先跟(前序)遍历：
                ①先访问根结点
                ②按照从左到右的顺序先根遍历每一棵子树
            2）、后根(后序)遍历：
                ①按照从左到右的顺序先根遍历每一棵子树
                ②先访问根结点
            3）、层次(中序)遍历
                ①先中序遍历左子树
                ②访问父结点
                ③再中序遍历右子树







                